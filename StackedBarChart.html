<!DOCTYPE html>
<meta charset="utf-8" />

<head>
    <script src="./Data/d3DefaultConfig.js"></script>
    <script src="./Data/utils.js"></script>
    <script src="./Data/d3.v4.min.js"></script>
    <script src="./Data/d3-scale-chromatic.v1.min.js"></script>
    <script src="./Data/min/numeral.min.js"></script>
    <link rel="stylesheet" href="Data/general.css" />
    <style>
        body {
            padding: 0;
            margin: 0;
        }

        .title {
            font: 15px sans-serif;
        }

        .axis path,
        .axis line {
            fill: none;
            shape-rendering: crispEdges;
            stroke-width: 1px;
        }

        .x.axis.path {
            display: none;
        }

        #tooltip {
            font-size: 14px;
            font-family: Arial, Helvetica, sans-serif;
            min-width: fit-content;
            max-width: max-content;
        }

        #my_dataviz {
            overflow-x: scroll;
            margin-left: 72px;
            height: 100vh;
        }

        #xAxisLabelId {
            position: fixed;
            bottom: 0px;
            z-index: 100;
            height: 40px;
            /* background-color: red; */
        }
    </style>
</head>

<body>
    <!-- html containers starts-->
    <div id="mainChartWindow" style="display: flex">
        <div id="yAxisDiv"></div>
        <div id="my_dataviz"></div>
        <div id="xAxisLabelId" style="position: fixed"></div>
    </div>

    <div id="tooltip"></div>

    <div id="legend"></div>
    <!-- html containers ends-->

    <script>

        var extraHeightWorked = false;
        var redrawn = false;
        var extraHeight = 0;

        // [Tag: Date Change]
        function transformData(dataValue, dataColumns = {}, dateFormat, dateFormat1) {
            json = {};
            var isKey1Date = false;
            var isKey2Date = false;

            // [Tag: Date Change]
            var { xAxisColumnDetails = [], colorByData = [] } = dataColumns;

            // [Tag: Date Change]
            if (xAxisColumnDetails[0].itemType == "Date") {
                isKey1Date = true;
            }
            // [Tag: Date Change]
            if (colorByData[0].itemType == "Date") {
                isKey2Date = true;
            }

            var uniqueKey2 = [];
            dataValue.forEach((d) => {
                if (isKey1Date) {
                    var key = getDateFormattedData(d[1], dateFormat);
                } else {
                    var key = d[1];
                }

                if (!json[key]) {
                    json[key] = {};
                }
                if (isKey2Date) {
                    var key2 = getDateFormattedData(d[0], dateFormat1);
                } else {
                    var key2 = d[0];
                }
                if (!uniqueKey2.includes(key2)) {
                    uniqueKey2.push(key2);
                }

                var value = d[2];

                if (!json[key][key2]) {
                    json[key][key2] = 0;
                }

                json[key][key2] += +value;
            });

            var allKeys = uniqueKey2;

            let response = Object.keys(json).map((key) => {
                return { ...json[key], key };
            });
            if (isKey1Date) {
                var sortedKeys = sortDates(json, dateFormat);
                response = sortedKeys.map((d) => {
                    return { ...json[d], key: d };
                });
            }

            var allKeys = uniqueKey2;

            return [response, allKeys, data[3]];
        }

        function drawChart(data, plottingConfiguration = {}) {
            if (!redrawn) {
                extraHeight = 0;
            }
            window.data = data;

            var timeFormat = d3.timeFormat("%m-%Y");
            var parseDate = d3.timeParse("%Y");
            var tooltipColumn1 = "test1";
            var tooltipColumn2 = "test2";
            // var [xAxisLabel, colorbyLabel, yAxisLabel] = data[2];

            let {
                d3colorPalette,
                paddingInner,
                markerShape,
                curveType,
                dateFormat,
                dateFormat1,
                chartType,
                toolTip = {},
                dataColumns, // [Tag: Date Change]
                legendConfig = defaultD3Config.defaultLegendConfig,
                labelConfig = defaultD3Config.defaultlabelConfig,
                gridConfig = defaultD3Config.defaultGridConfig,
                standardThresholdWidth,
                // font size
                xLabelfontSize = defaultD3Config.fontSize,
                yLabelfontSize = defaultD3Config.fontSize,
                xTickfontSize = defaultD3Config.fontSize,
                yTickfontSize = defaultD3Config.fontSize,
                dataLabelfontSize = defaultD3Config.fontSize,
                // font family
                xLabelfontFamily = defaultD3Config.fontFamily,
                yLabelfontFamily = defaultD3Config.fontFamily,
                xTickfontFamily = defaultD3Config.fontFamily,
                yTickfontFamily = defaultD3Config.fontFamily,
                dataLabelfontFamily = defaultD3Config.fontFamily,
                // font color
                xLabelfontColor = defaultD3Config.fontColor,
                yLabelfontColor = defaultD3Config.fontColor,
                xTickfontColor = defaultD3Config.fontColor,
                yTickfontColor = defaultD3Config.fontColor,
                dataLabelColor = defaultD3Config.fontColor,
                // xaxis setting
                xAxisConfig = defaultD3Config.xAxisConfig,
                yAxisConfig = defaultD3Config.yAxisConfig
            } = plottingConfiguration;

            // plottingConfiguration restore from windows
            window.xLabelfontSize = xLabelfontSize;
            window.yLabelfontSize = yLabelfontSize;
            window.xTickfontSize = xTickfontSize;
            window.yTickfontSize = yTickfontSize;
            window.dataLabelfontSize = dataLabelfontSize;

            window.xLabelfontFamily = xLabelfontFamily;
            window.yLabelfontFamily = yLabelfontFamily;
            window.xTickfontFamily = xTickfontFamily;
            window.yTickfontFamily = yTickfontFamily;
            window.dataLabelfontFamily = dataLabelfontFamily;

            window.xLabelfontColor = xLabelfontColor;
            window.yLabelfontColor = yLabelfontColor;
            window.xTickfontColor = xTickfontColor;
            window.yTickfontColor = yTickfontColor;
            window.dataLabelColor = dataLabelColor;

            let { legendStatus, legendPosition } = legendConfig;
            let { labelStatus, labelFormat } = labelConfig;
            let { gridStatus } = gridConfig;
            let { xlabel, xboldLabel, xitalicLabel, xboldTick, xitalicTick, xaxisStatus } = xAxisConfig;
            let { ylabel, yboldLabel, yitalicLabel, yboldTick, yitalicTick, yaxisStatus } = yAxisConfig;
            window.yboldLabel = yboldLabel;
            window.xboldLabel = xboldLabel;
            window.xitalicLabel = xitalicLabel;
            window.yitalicLabel = yitalicLabel;
            if (!xAxisConfig.xlabel && !yAxisConfig.ylabel) {
                [xAxisLabel, yAxisLabel, colorData] = data[3];
                console.log(data);
            } else {
                [xAxisLabel, yAxisLabel, colorData] = [xAxisConfig.xlabel, yAxisConfig.ylabel, data[3][2]];
            }

            d3.selectAll("#my_dataviz").html("");
            d3.selectAll("#yAxisDiv").html("");
            d3.selectAll("#legend").html("");
            var { xAxisColumnDetails = [], colorByData = [] } = dataColumns;
            // if (colorByData[0].itemName == xAxisColumnDetails[0].itemName){

            // }
            if (!d3colorPalette) {
                d3colorPalette = defaultD3Config.d3ColorPalette;
            }
            d3Colors = d3colorPalette;

            if (!paddingInner) {
                paddingInner = defaultD3Config.defaultPaddingInner;
            }

            if (!dateFormat) {
                dateFormat = defaultD3Config.dateFormat;
            }

            if (!dateFormat1) {
                dateFormat1 = defaultD3Config.dateFormat;
            }

            if (!chartType) {
                chartType = defaultD3Config.chartType;
            }

            if (!standardThresholdWidth) {
                standardThresholdWidth = defaultD3Config.standardThresholdWidth;
            }

            let { top, right, bottom, left } = constants.chartMargins;
            // if (window.innerHeight < 400) {
            //     top = top / 2 + 10;
            //     right = right / 2;
            //     // bottom = bottom / 2;
            // }
            var margin = { top, right, bottom, left };
            var width = window.innerWidth - margin.left - margin.right - 20;
            var y_pos_x_label = 55;
            var topLegendMargin = 0;

            var [data, keys, labels] = transformData(
                data[0],
                dataColumns, // [Tag: Date Change]
                dateFormat,
                dateFormat1
            );

            d3.select("#legend").attr("style", null);
            d3.select("#mainChartWindow").attr("style", null);
            d3.select("#xAxisLabelId").style("bottom", 5 + "px");

            if (legendStatus) {
                d3.select("#legend").html("").style("padding", "");
                // if (legendStatus) {
                //     d3.select("#legend").html("");

                d3.select("#legend")
                    .append("p")
                    .html(labels && labels[2] + "&nbsp;")
                    .style("font-weight", "bold")
                    .style("margin", "auto")
                    .style("position", "sticky");

                // d3.select("#legend").html("");
                d3.select("#legend")
                    .selectAll("div")
                    .data(keys)
                    .enter()
                    .append("div")
                    .html((d, i) => {
                        return (
                            '<div style="width: 15px; height: 15px; margin-top:2px; background: ' +
                            d3Colors[i % d3Colors.length] +
                            ';">  </div>' +
                            "<span style='margin-left: 5px; max-width: 160px'>" +
                            d +
                            "</span>"
                        );
                    })
                    .style("display", "flex")
                    .style("padding", "5px");
            }

            // legends code ends

            // legends height ,width elements
            var legendElement = document.querySelector("#legend");
            var legendHeight = legendElement.offsetHeight;
            var legendWidth = legendElement.offsetWidth;
            var htmlHeight = window.innerHeight;
            var htmlWidth = window.innerWidth;

            const yAxisWidth = document.querySelector("#yAxisDiv").clientWidth;

            var height = window.innerHeight - margin.top - margin.bottom - 2 - extraHeight / 2;

            if (extraHeight) {
                height = height - 20;
                if (legendStatus && (legendPosition == "top" || legendPosition == "bottom")) {
                    height -= 20;
                }
            } else {
                if (!legendStatus) {
                    height += 10;
                }
                if (legendStatus && (legendPosition == "top" || legendPosition == "bottom")) {
                    height -= 15;
                }
            }
            // legends code starts

            if (legendStatus) {
                if (legendHeight < htmlHeight) {
                    topPosition = "calc(50vh - " + legendHeight / 2 + "px)";
                } else {
                    topPosition = "0px";
                }

                var widthOld = document.querySelector("html").clientWidth - 72;
                var heightOld = document.querySelector("html").clientHeight;

                // legendElement.style.padding = "10px";
                legendElement.style.border = "1px solid black";

                switch (legendPosition) {
                    case "left":
                        var legendWidth = legendElement.offsetWidth;
                        // width -= 70;

                        d3.select("#legend")
                            .attr("style", null)
                            .style("right", "auto")
                            .style("left", "auto")
                            .style("position", "fixed")
                            .style("top", topPosition)
                            .style("max-height", "100vh")
                            .style("overflow", "scroll")
                            .style("border", "none")
                            .style("bottom", "auto")
                            .style("display", "block");
                        d3.selectAll("#legend div span")
                            .style("max-width", "160px")
                            .style("white-space", "nowrap")
                            .style("overflow", "hidden")
                            .style("text-overflow", "ellipsis");

                        // debugger;
                        d3.select("#mainChartWindow").attr("style", null);
                        d3.select("#mainChartWindow").style("width", widthOld - legendWidth + yAxisWidth + "px");
                        d3.select("#mainChartWindow").style("margin-left", legendWidth + "px");
                        d3.select("#xAxisLabelId").style("bottom", 5 + "px");

                        break;
                    case "top":
                        margin.top += 18;
                        margin.bottom += 20;
                        topLegendMargin += 20;

                        height += 5;
                        // y_pos_x_label = 57
                        d3.select("#legend")
                            .attr("style", null)
                            .style("top", "10px")
                            .style("bottom", "auto")
                            .style("left", "auto")
                            .style("display", "flex")
                            .style("max-width", "99vw")
                            .style("overflow", "scroll")

                            .style("border", "none");

                        d3.selectAll("#legend div span")
                            .style("max-width", "160px")

                            .style("white-space", "nowrap")
                            .style("overflow", "hidden")
                            .style("text-overflow", "ellipsis");
                        d3.selectAll("#legend p").style("min-width", "fit-content");

                        d3.select("#mainChartWindow").attr("style", null);

                        legendWidth = legendElement.offsetWidth;
                        if (legendWidth < htmlWidth) {
                            rightPosition = "calc(50vw - " + legendWidth / 2 + "px)";
                        } else {
                            rightPosition = "0px";
                        }
                        d3.select("#legend").style("right", rightPosition);

                        d3.select("#xAxisLabelId").style("bottom", 5 + "px");

                        break;
                    case "bottom":
                        height -= 15;
                        // y_pos_x_label = 57

                        d3.select("#xAxisLabelId").style("bottom", 45 + "px");
                        // d3.select("#my_dataviz").style("bottom", 50 + "px");
                        // d3.select("#my_dataviz").style("height", 500 + "px");
                        d3.select("#mainChartWindow").attr("style", null);
                        d3.select("#legend")
                            .attr("style", null)
                            .style("top", "auto")
                            .style("bottom", "0px")
                            .style("left", "auto")
                            .style("display", "flex")
                            .style("max-width", "99vw")
                            .style("overflow", "scroll")
                            // .style("right", rightPosition)
                            .style("border", "none");

                        d3.selectAll("#legend div span")
                            .style("max-width", "160px")
                            .style("white-space", "nowrap")
                            .style("overflow", "hidden")
                            .style("text-overflow", "ellipsis");
                        d3.selectAll("#legend p").style("min-width", "fit-content");
                        d3.select("#mainChartWindow").attr("style", null);

                        legendWidth = legendElement.offsetWidth;
                        if (legendWidth < htmlWidth) {
                            rightPosition = "calc(50vw - " + legendWidth / 2 + "px)";
                        } else {
                            rightPosition = "0px";
                        }
                        d3.select("#legend").style("right", rightPosition);

                        // d3.select("#mainChartWindow").style("height", "500px");
                        // d3.select("#mainChartWindow").style("height", "500px");
                        break;
                    // For Right Legened
                    case "right":
                    default:
                        // width -= 220;
                        // d3.select("#my_dataviz").style("width", width + margin.left + margin.right);
                        var legendWidth = legendElement.offsetWidth;
                        // width = 70;

                        d3.select("#legend")
                            .attr("style", null)
                            .style("right", "5px")
                            .style("left", "auto")
                            .style("position", "fixed")
                            .style("top", topPosition)
                            .style("max-height", "100vh")
                            .style("overflow", "scroll")
                            .style("border", "none")
                            .style("bottom", "auto")
                            .style("display", "block");
                        d3.selectAll("#legend div span")
                            .style("max-width", "160px")
                            .style("white-space", "nowrap")
                            .style("overflow", "hidden")
                            .style("text-overflow", "ellipsis");

                        d3.select("#mainChartWindow").attr("style", null);
                        d3.select("#mainChartWindow").style(
                            "width",
                            widthOld - legendWidth + yAxisWidth - 20 + "px"
                            // "500px"
                        );
                        d3.select("#mainChartWindow").style("margin-left", 0);
                        d3.select("#xAxisLabelId").style("bottom", 5 + "px");
                }
            }

            if (legendStatus && (legendPosition == "left" || legendPosition == "right")) {
                var legendWidth = legendElement.offsetWidth;
                width -= legendWidth;
                height += 10;
            }
            if (legendStatus && legendPosition == "top") {
                var legendHeightTop = 20;
            } else {
                legendHeightTop = 0;
            }
            if (legendStatus && legendPosition == "left") {
                var legendWidthLeft = legendWidth;
            } else {
                legendWidthLeft = 0;
            }

            // legends code ends

            toolTip.textColumn1 = toolTip.textColumn1 || (labels && labels[0]);
            toolTip.textColumn2 = toolTip.textColumn2 || (labels && labels[1]);
            toolTip.colorData = toolTip.colorData || (labels && labels[2]);

            if (chartType == constants.chartType.STANDARD) {
                width = data.length * standardThresholdWidth;
            }

            // var height = window.innerHeight - margin.top - margin.bottom - 2 - extraHeight
            // window.innerHeight - margin.top - margin.bottom - extraHeight - 2;
            yaxisTicks = height / 70;

            var x = d3
                .scaleBand()
                .range([0, width])
                .domain(
                    data.map((d) => {
                        return d.key;
                    })
                )
                .padding(paddingInner)
                .paddingInner(paddingInner);

            var y = d3.scaleLinear().range([height, margin.top]);
            var center = d3.scaleLinear().range([0, width]);
            var color = d3.scaleOrdinal().range(d3Colors);

            var xAxis = d3.axisBottom(x);
            var yAxis = d3.axisLeft(y).ticks(yaxisTicks).tickFormat(d3.format(".2s"));

            var centerLine = d3.axisTop(center).ticks(0);

            data.forEach(function (d) {
                var y0_positive = 0;
                var y0_negative = 0;

                var mainKey = d.key;

                d.components = keys.map(function (key) {
                    if (d[key] >= 0) {
                        return {
                            key,
                            mainKey,
                            y1: y0_positive,
                            y0: (y0_positive += d[key])
                        };
                    } else if (d[key] < 0) {
                        return {
                            key,
                            mainKey,
                            y0: y0_negative,
                            y1: (y0_negative += d[key])
                        };
                    }
                });
            });

            var y_min = d3.min(data, function (d) {
                return d3.min(
                    d.components.map((d1) => {
                        return d1.y1;
                    })
                );
            });

            var y_max = d3.max(data, function (d) {
                return d3.max(
                    d.components.map((d1) => {
                        return d1.y0;
                    })
                );
            });

            if (y_min > 0) {
                y_min = 0;
            }

            y.domain([y_min, y_max]).nice();
            color.domain(keys);
            const barWidth = x.bandwidth();

            window.clearChart && clearChart();

            //add svg with margin !important
            //this is svg is actually group
            var svg = d3
                .selectAll("#my_dataviz")
                .append("svg")
                .attr("width", width)
                .attr("height", height + margin.bottom + margin.top + extraHeight)
                .append("g")
                .attr("transform", "translate(" + 0 + "," + margin.top + ")");

            if (gridStatus) {
                svg.append("g")
                    .attr("class", "grid")
                    .style("stroke-width", "1")
                    .call(make_y_gridlines(y).tickSize(-width).tickFormat(d3.format(".2s")));
            } else {
                svg.append("g")
                    .attr("class", "grid")
                    .style("stroke-width", "1")
                    .style("display", "none")
                    .call(make_y_gridlines(y).tickSize(-width).tickFormat(d3.format(".2s")));
            }

            svg.append("g")
                .attr("class", "x-axis axis")
                .attr("text-anchor", "end")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis.tickSize(0));

            d3.select("#yAxisDiv")
                .append("svg")
                .attr("width", "72")
                .attr("height", height + margin.top + margin.bottom)
                .append("g") //add group to leave margin for axis
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
                .append("g")
                .attr("class", "y-axis")
                .call(yAxis.tickSize(-width));

            // svg.append("g")
            //     .attr("class", "y axis grid")
            //     .call(yAxis.tickSize(-width));

            svg.append("g")
                .attr("class", "centerline")
                .attr("transform", "translate(0," + y(0) + ")")
                .call(centerLine.tickSize(0));

            var entry = svg
                .selectAll(".entry")
                .data(data)
                .enter()
                .append("g")
                .attr("class", "g")
                .attr("transform", function (d) {
                    return "translate(" + x(d.key) + ", 0)";
                });

            entry
                .selectAll("rect")
                .data(function (d) {
                    return d.components;
                })
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("width", x.bandwidth())
                .attr("y", function (d) {
                    return y(d.y0);
                })
                .attr("height", function (d) {
                    this.setAttribute("data-value-x", d.mainKey);
                    this.setAttribute("data-value-y", d.key);

                    var yValue = d.y0 - d.y1;
                    if (d.y1 < 0) {
                        yValue = d.y1 - d.y0;
                    }
                    this.setAttribute("data-value-y1", Math.round(yValue));

                    return Math.abs(y(d.y0) - y(d.y1));
                })

                .style("fill", function (d) {
                    return color(d.key);
                })
                .on("mouseout", function (d, i) {
                    d3.select("#tooltip").style("display", "none");
                    d3.selectAll(".bar").style("opacity", 1);
                })
                .on("mouseover mousemove", function (d, i) {
                    let xpos = d3.mouse(this)[0] + margin.left;
                    // let ypos = d3.mouse(this)[1];

                    var parentElement = this.parentElement;

                    const matrix = window.getComputedStyle(parentElement).transform;

                    const matrixValues = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");

                    xpos += +matrixValues[4] || 0;

                    let ypos = d3.mouse(this)[1];

                    let xValue = this.getAttribute("data-value-x");
                    let yValue = this.getAttribute("data-value-y");
                    let y1Value = this.getAttribute("data-value-y1");

                    d3.select("#tooltip")
                        .style("top", ypos - 52 + legendHeightTop + "px")
                        .style("display", "block")
                        .html(function () {
                            return (
                                "<div class='arrowTooltip'></div>" +
                                "<span style='color:grey;''>" +
                                toolTip.textColumn1 +
                                ":&nbsp;&nbsp;" +
                                "</span>" +
                                "<span style='float: right;'>" +
                                xValue +
                                "</span>" +
                                "<br/> <br/>" +
                                "<span style='color:grey;''>" +
                                toolTip.colorData +
                                ":&nbsp;&nbsp;" +
                                "</span>" +
                                "<span style='float: right;'>" +
                                yValue +
                                "</span>" +
                                "<br/> <br/>" +
                                "<span style='color:grey;''>" +
                                toolTip.textColumn2 +
                                ":" +
                                "</span>" +
                                "<span style='float: right;margin-left: 15px;'>" +
                                (y1Value && Math.round(+y1Value)) +
                                "</span>"
                            );
                        });
                    var scrollVal = document.querySelector("#my_dataviz").scrollLeft;

                    if (
                        xpos - scrollVal >
                        document.documentElement.clientWidth - document.querySelector("#tooltip").clientWidth
                    ) {
                        d3.select("#tooltip").style(
                            "left",
                            xpos -
                                scrollVal -
                                document.querySelector("#tooltip").clientWidth -
                                10 +
                                legendWidthLeft +
                                "px"
                        );

                        d3.select(".arrowTooltip")
                            //  document.querySelector("#tooltip:before")
                            // .style("height","50px";"width","50px";"background-color","red";")

                            .attr(
                                "style",
                                "border: solid; border-color: white transparent; border-width: 12px 6px 0 6px; content: '';right: -12px; transform: rotate(-90deg)!important;bottom: 22px; position: absolute;"
                            );
                    } else {
                        d3.select("#tooltip").style("left", xpos - scrollVal + legendWidthLeft + 12 + "px");

                        d3.select(".arrowTooltip").attr(
                            "style",
                            "border: solid; border-color: white transparent; border-width: 12px 6px 0 6px; content: '';left: -12px; transform: rotate(90deg)!important;bottom: 22px; position: absolute;"
                        );
                    }

                    d3.selectAll(".bar").style("opacity", 0.3);
                    d3.select(this).style("opacity", 1);
                });

            if (labelStatus) {
                entry
                    .selectAll("text.label")
                    .data(function (d) {
                        return d.components;
                    })
                    .enter()
                    .append("text")
                    .attr("class", "label")
                    .attr("width", x.bandwidth())
                    .attr("y", function (d) {
                        // return (y(d.y0))
                        return y(d.y0) + Math.abs(y(d.y0) - y(d.y1)) / 2 + 6;
                    })
                    .attr("x", x.bandwidth() / 2 - 15)
                    .attr("display", function (d) {
                        if (Math.abs(y(d.y0) - y(d.y1)) < 20) {
                            return "none";
                        } else {
                            return "";
                        }
                    })
                    .attr("font-family", dataLabelfontFamily)
                    .attr("font-size", dataLabelfontSize)
                    .attr("fill", dataLabelColor)
                    .text(function (d) {
                        return labelFormatSet(d.y1 >= 0 ? d.y0 - d.y1 : d.y1 - d.y0, labelFormat);
                    });
            }
            d3.selectAll("#yAxisDiv text")
                .attr("font-size", yTickfontSize)
                .attr("font-family", yTickfontFamily)
                .attr("font-weight", yboldTick ? "bold" : "regular")
                .attr("font-style", yitalicTick ? "italic" : "regular")
                .attr("fill", yTickfontColor);
            d3.selectAll(".x-axis text")
                .attr("font-size", xTickfontSize)
                .attr("font-family", xTickfontFamily)
                .attr("font-weight", xboldTick ? "bold" : "regular")
                .attr("font-style", xitalicTick ? "italic" : "regular")
                .attr("fill", xTickfontColor)
                .attr("y", 6);
            if (xaxisStatus) {
                d3.selectAll("g .x-axis").attr("style", "display: block");
            } else {
                d3.selectAll("g .x-axis").attr("style", "display: none");
            }
            if (yaxisStatus) {
                d3.selectAll("g .y-axis").attr("style", "display: block");
            } else {
                d3.selectAll("g .y-axis").attr("style", "display: none");
            }

            setYaxisWidth();

            if (chartType == constants.chartType.FIT_WIDTH && barWidth < 40) {
                setXaxisWidth();
            }

            if (chartType == constants.chartType.STANDARD) {
                setStandardTickWidths();
            }

            function setStandardTickWidths() {
                var a = document.querySelectorAll(".x-axis .tick text");

                for (var i = 0; i < a.length; i++) {
                    var singleCharacterLength = a[i].getBBox().width / a[i].innerHTML.length;
                    var numOfCharacters = Math.floor(barWidth / singleCharacterLength);

                    var tick = a[i];

                    var tickWidth = tick && tick.getBBox().width;
                    if (tickWidth > barWidth) {
                        var tickValue = tick.innerHTML;
                        tickValue = tickValue && tickValue.substr(0, numOfCharacters - 3) + "...";
                        tick.innerHTML = tickValue;
                    }
                }
            }

            function setXaxisWidth() {
                var allYAxisTicks = document.querySelectorAll(".x-axis .tick text");
                var maxWidth = 0;
                for (var i = 0; i < allYAxisTicks.length; i++) {
                    var tick = allYAxisTicks[i];
                    var width = tick.getBBox().width;
                    if (width > maxWidth) {
                        maxWidth = width;
                    }
                }

                extraHeightWorked = true;
                maxWidth = maxWidth < 100 ? maxWidth : 100;
                extraHeight = maxWidth;

                d3.select(".x-axis").attr("text-anchor", "right");

                d3.selectAll(".x-axis text")
                    .attr("transform", "rotate(-90)")
                    .attr("dy", "0.3em")
                    .attr("text-anchor", "end")
                    // .attr("x", "-" + (maxWidth + 3))
                    .attr("x", "-" + 10)
                    .attr("y", "0");
            }

            function make_x_gridlines(x) {
                return d3.axisBottom(x).ticks(yaxisTicks);
            }
            function make_y_gridlines(y) {
                return d3.axisLeft(y).ticks(yaxisTicks).tickFormat(d3.format(".2s"));
            }

            // if (labelStatus) {
            //     svg.append("g")
            //         .attr("class", "axis label")
            //         // .attr("transform", "translate(0," + 100 + ")")
            //         .attr("font-family", xTickfontFamily)
            //         .call(xAxis.tickSize(0));

            //     // .attr("transform", "translate(0,0)");
            //     var labelSelector =
            //         document.querySelectorAll(".axis.label text");

            //     labelSelector.forEach((label, i) => {
            //         var labelValue = label.textContent;
            //         // var labelYPosition = yScale(data[0][1][i])
            //         console.log(data[0]);
            //         label.setAttribute("y", 200);
            //         //  label.textContent = textColumn2[1];
            //         label.textContent = "i";
            //         // label.textContent = data[0][0][2];
            //     });
            // }

            setLabel(
                xAxisLabel,
                "x_label",
                d3.select("#xAxisLabelId").append("svg").attr("width", window.innerWidth, "height", 150),
                y_pos_x_label,
                false
            );
            setLabel(yAxisLabel, "y_label", d3.select("svg"), false);

            function getLeftAxisDistance() {
                var a = document.querySelector(".tick").getAttribute("transform");
                a = a.replace("translate(", "");
                return a.substr(0, a.indexOf(","));
            }

            allXAxisTexts = document.querySelectorAll(".x-axis text");
            var textWidth = document.querySelector(".x-axis .tick text").getBBox().height;

            if (chartType == constants.chartType.FIT_WIDTH && x.bandwidth() < 40) {
                for (var i = 0; i < allXAxisTexts.length; i++) {
                    if (!Math.floor(data.length * 0.02)) {
                        break;
                    }
                    if (i % Math.floor(data.length * 0.02) != 0) {
                        allXAxisTexts[i].remove();
                        continue;
                    }

                    if (allXAxisTexts[i] && allXAxisTexts[i].innerHTML) {
                        var singleCharacterLength =
                            allXAxisTexts[i].getBBox().width / allXAxisTexts[i].innerHTML.length;

                        var numOfCharacters = extraHeight / singleCharacterLength;

                        if (allXAxisTexts[i].innerHTML && allXAxisTexts[i].innerHTML.length > numOfCharacters) {
                            if (Math.floor(numOfCharacters) > 3) {
                                allXAxisTexts[i].innerHTML =
                                    (allXAxisTexts[i].innerHTML &&
                                        allXAxisTexts[i].innerHTML.substr(0, numOfCharacters - 3)) + "...";
                            } else {
                                allXAxisTexts[i].innerHTML =
                                    (allXAxisTexts[i].innerHTML && allXAxisTexts[i].innerHTML.substr(0, 2)) + "...";
                            }
                        }
                    }

                    if (i == 0 && barWidth < textWidth * 0.5) {
                        allXAxisTexts[i].setAttribute("dy", "1em");
                        continue;
                    }
                    if (barWidth < textWidth * 0.5) {
                        allXAxisTexts[i].setAttribute("dy", "0.8em");
                    }
                }
            }

            if (extraHeightWorked && !redrawn) {
                extraHeightWorked = false;
                redrawn = true;
                drawChart(window.data, plottingConfiguration);
                var mainChart = document.querySelector("#my_dataviz svg");
                var heightValue = mainChart.getAttribute("height");
                heightValue = +heightValue + extraHeight;
                mainChart.setAttribute("height", heightValue);
            }

            if (extraHeightWorked && redrawn) {
                extraHeightWorked = false;
                redrawn = false;
            }

            setXAxisTicksDistance();
            function setYaxisWidth() {
                var allYAxisTicks = document.querySelectorAll(".y-axis .tick");
                var maxWidth = 72;
                for (var i = 0; i < allYAxisTicks.length; i++) {
                    var tick = allYAxisTicks[i];
                    var width = tick.getBBox().width + 25;
                    if (width > maxWidth) {
                        maxWidth = width;
                    }
                }

                var yAxisDiv = document.querySelector("#yAxisDiv svg");

                yAxisDiv.setAttribute("width", maxWidth);
                yAxisDiv.setAttribute("transform", "translate(" + (maxWidth - margin.left) + "," + 0 + ")");
            }

            function getDateFormattedData(dateValue, dateFormat) {
                return d3.timeFormat(dateFormat)(new Date(dateValue));
            }
        }

        // window.addEventListener("resize", function () {
        //     window.clearChart && clearChart();
        // drawChart(data, {
        //     chartType: "FitWidth",
        //     // xAxisConfig: { xlabel: "Category" },
        //     // yAxisConfig: { ylabel: "Sales" },
        //     dataColumns: {
        //         xAxisColumnDetails: [
        //             {
        //                 itemName: "Category",
        //                 itemType: "Categorical",
        //                 dateFormat: "%Y"
        //             }
        //         ],
        //         yAxisColumnDetails: [
        //             {
        //                 itemName: "Sales",
        //                 itemType: "Numerical",
        //                 dateFormat: "%Y"
        //             }
        //         ],
        //         row3ColumnDetails: [],
        //         colorByData: [{ columnName: "Sub_Category", itemType: "Categorical" }]
        //     }
        // });
        // });
    </script>
</body>
